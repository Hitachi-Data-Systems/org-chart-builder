#!/usr/bin/pythonimport globimport osimport sysfrom spreadsheet_parser import SpreadsheetParserimport argparse__author__ = 'doreper'SOFT_WRAP_NUM = 6HARD_WRAP_NUM = 8class PeopleDataKeys:    MANAGER = "Manager"    NAME = "Name"    LEVEL = "Level"    FUNCTION = "Function"    PROJECT = "Project"    TYPE = "Type"    REQ = "Requisition Number"    CONSULTANT = "Consultant"    EXPAT = "Expat"    CROSS_FUNCTIONS = ["Admin", "Inf", "Infrastructure", "Tech"]    CROSS_FUNCT_TEAM = "Cross"    CONSULTANT_DECORATOR = "**"    MANAGER_DECORATOR = "=="    FLOORS = {}class PeopleDataKeysWaltham(PeopleDataKeys):    PROJECT = "Product Team"    FUNCTION = "Functional Team"    TYPE = "Employee Type"    LEVEL = "Title"    REQ = "Requisition"    FLOORS = {"FLOOR2":[], "FLOOR3":["HCP"]}class OrgPrinter:    def __init__(self, workbookName, dataSheetName):        """        :type workbookName: str        :type dataSheetName: str        """        self.peopleDataKeys = PeopleDataKeys        if "waltham" in workbookName.lower():            self.peopleDataKeys = PeopleDataKeysWaltham        self.spreadsheetParser = SpreadsheetParser(workbookName, dataSheetName)        self.managerList = self.getManagerList()    def getManagerList(self):        """        :return:        """        managerSet = set()        for aRow in self.spreadsheetParser.dataRows():            managerName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.MANAGER)            if not managerName:                continue            managerSet.add(managerName)        return managerSet    def getProductList(self):        """        :return:        """        productList = set()        for aRow in self.spreadsheetParser.dataRows():            productName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.PROJECT)            if not productName:                continue            productList.add(productName)        return productList    def getFunctionList(self):        functionList = set()        for aRow in self.spreadsheetParser.dataRows():            functionName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.FUNCTION)            if not functionName:                continue            functionList.add(functionName)        return functionList    def isManager(self, name):        """        :type name: unicode or unknown        :return:        """        return name in self.managerList    def getAdminDict(self):        """        :rtype : dict        :return:        """        managerDict = {}        for aRow in self.spreadsheetParser.dataRows():            managerName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.MANAGER)            personName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.NAME)            if not personName:                continue            if not managerName:                managerName = "_Manager Not Set"            # if not self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.PROJECT):            #     continue            if managerName not in managerDict:                managerDict[managerName] = []            managerDict[managerName].append(self.getFormattedNameByRow(aRow))        return managerDict    def getProdFuncDict(self):        """        :rtype : dict        :return:        """        prodDict = {}        for aRow in self.spreadsheetParser.dataRows():            additionalData = ""            prodName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.PROJECT)            personName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.NAME)            if not personName:                continue            if not prodName:                prodName = "_Product not set"            funcName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.FUNCTION)            if not funcName:                funcName = "_Function not set"            if funcName in self.peopleDataKeys.CROSS_FUNCTIONS:                prodName = self.peopleDataKeys.CROSS_FUNCT_TEAM            if self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.TYPE) == self.peopleDataKeys.EXPAT:                prodName = self.peopleDataKeys.EXPAT                additionalData = " ({})".format(self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.PROJECT))            if prodName not in prodDict:                prodDict[prodName] = {}            if funcName not in prodDict[prodName]:                prodDict[prodName][funcName] = []            prodDict[prodName][funcName].append(self.getFormattedNameByRow(aRow) + additionalData)        return prodDict    def isConsultant(self, aRow):        """        :type aRow: tuple        :return:        """        typeStr = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.TYPE) or ""        return typeStr.lower() == self.peopleDataKeys.CONSULTANT.lower()    def getFormattedNameByRow(self, aRow):        """        :type aRow: tuple        :return:        """        formattedName = self.getFormattedName(aRow)        if self.isConsultant(aRow):            formattedName += PeopleDataKeys.CONSULTANT_DECORATOR        if self.isManager(self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.NAME)):            formattedName += PeopleDataKeys.MANAGER_DECORATOR        return formattedName    def getFormattedNameByPerson(self, name):        """        :param name:        :return:        """        for aRow in self.spreadsheetParser.dataRows():            if name == self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.NAME):                return self.getFormattedName(aRow)        return name    def getFormattedName(self, aRow):        """        :type name: unicode or unknown        :type level: unicode or unknown        :return:        """        formattedName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.NAME).strip()        splitName = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.NAME).strip().split(",")        if len(splitName) > 1:            formattedName = "{} {}".format(splitName[-1].strip(), splitName[0].strip())        if formattedName.lower().startswith("tbh"):            req = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.REQ).strip()            if req:                formattedName = "{}<br>{}".format(formattedName, req)        level = self.spreadsheetParser.getColValueByName(aRow, self.peopleDataKeys.LEVEL).strip()        if level:            formattedName = "{name}<br>{level}".format(name=formattedName,                                       level=level)        return formattedName    def printAdmin(self):        """        """        adminDict = self.getAdminDict()        managerList = adminDict.keys()        managerList.sort()        for aManager in managerList:            print self.getFormattedNameByPerson(aManager)            sortedPeople = adminDict[aManager]            sortedPeople.sort()            for aPerson in sortedPeople:                print "\t{}".format(aPerson)    def getSortedFuncList(self):        return ["Lead", "PO","Product Owner", "Technology", "TA", "Tech", "SW Architecture", "Dev", "Development", "QA", "Stress",                "Characterization", "Auto", "Aut", "Automation","Sustaining", "Solutions and Sustaining",                 "UI", "UX", "Inf", "DevOps", "Cross Functional", "Cross", "Doc"]    def _getFunctionStr(self, functionName, members, msg=""):        if len(members) > HARD_WRAP_NUM:            return self._getFunctionStr(functionName, members[:SOFT_WRAP_NUM], msg) + self._getFunctionStr(functionName, members[SOFT_WRAP_NUM:], msg)        else:            msg += "\t{}{}".format(functionName, os.linesep)            namesInFunc = members[:]            namesInFunc.sort()            # Move TBH to bottom of the list            tbhList = [aName for aName in namesInFunc if "tbh" in aName.lower()]            namesInFunc = [aName for aName in namesInFunc if "tbh" not in aName.lower()]            namesInFunc.extend(tbhList)            for aName in namesInFunc:                msg += "\t\t{}{}".format(aName, os.linesep)            return msg    def _getFormattedFuncStr(self):        msg = ""        functionalDict = self.getProdFuncDict()        for aProduct in functionalDict.keys():            msg += "{}{}".format(aProduct, os.linesep)            for aFunction in self.getSortedFuncList():                if aFunction in functionalDict[aProduct]:                    msg += self._getFunctionStr(aFunction, functionalDict[aProduct][aFunction])                    functionalDict[aProduct].pop(aFunction)            for aFunction in functionalDict[aProduct]:                msg += self._getFunctionStr(aFunction, functionalDict[aProduct][aFunction])        return msg    def printFunctional(self):        print(self._getFormattedFuncStr())def main(argv):    userDir = os.environ.get("USERPROFILE") or os.environ.get("HOME")    defaultSheetName = "PeopleData"    defaultDir = os.path.join(userDir, "Documents/HCP Anywhere/Org Charts and Hiring History")    examples = """    Examples:    # Print functional layout for Waltham Staff. Uses unique identifier for a file in default director: {}        %prog Waltham Staff -f    # Print Admin layout for Bellevue. Uses fully qualified path to the spreadsheet        %prog C:\Users\doreper\Documents\HCP Anywhere\Org Charts and Hiring History\Bellevue Staff.xlsm -a    # Print Admin layout for Waltham. Uses fully qualified path to the spreadsheet. Uses unique identifier    # for file in the specified directory        %prog ham staff -d {}\Documents\HCP Anywhere\Org Charts and Hiring History\ -a    """.format(defaultDir, userDir)    parser = argparse.ArgumentParser(description="""This tool is used to parse staff spreadsheet and display information in a format that can"                                                 "easily be pasted into an excel smartArt chart builder""", epilog=examples, formatter_class=argparse.RawDescriptionHelpFormatter)    parser.add_argument("path", nargs="+", type=str, help="unique file token for file in directory specified by '-d [default={}' ".format(defaultDir))    parser.add_argument("-d", "--directory", type=str, help="directory for the spreadsheet",                        default=defaultDir)    parser.add_argument("-s", "--sheetName", type=str, default=defaultSheetName, help="Sheet Name")    parser.add_argument("-a", "--admin", action="store_true", help="print admin layout")    parser.add_argument("-f", "--func", action="store_true", help="print func layout")    options = parser.parse_args(argv)    if not (options.admin or options.func):        parser.error("You must specify whether to print functional and/or admin layout")    specifiedPath = " ".join(options.path)    if os.path.exists(specifiedPath):        workbookPath = specifiedPath    else:        fileMatch = glob.glob(os.path.join(options.directory, "*{}*".format(specifiedPath)))        fileMatch = [aFile for aFile in fileMatch if (not ((os.path.basename(aFile).startswith("~")) or "conflict" in os.path.basename(aFile).lower()))]        if not fileMatch:            raise OSError("Could not find any files in directory: '{}' that contain string: '{}'"                          .format(options.directory, specifiedPath))        if len(fileMatch) > 1:            raise OSError("Too many files found in dir: '{}' that contain string '{}' : \n\t\t{}".format(options.directory,                                                                                                   specifiedPath,                                                                                                   "\n\t\t".join(fileMatch)))        workbookPath = fileMatch[0]    orgPrinter = OrgPrinter(workbookPath, options.sheetName)    if options.func:        orgPrinter.printFunctional()    if options.admin:        orgPrinter.printAdmin()if __name__ == "__main__":    main(sys.argv[1:])